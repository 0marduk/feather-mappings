import java.nio.charset.Charset
import java.nio.file.NoSuchFileException
import java.util.List
import groovy.json.JsonSlurper

import com.google.common.io.Files
import com.google.common.hash.Hashing
import com.google.common.net.UrlEscapers
import cuchaz.enigma.command.ConvertMappingsCommand
import net.fabricmc.stitch.commands.CommandSplitTiny
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils
import net.ornithemc.mappingutils.MappingUtils
import net.ornithemc.mappingutils.PropagationDirection
import net.ornithemc.mappingutils.PropagationOptions
import net.ornithemc.mappingutils.io.Format
import net.ornithemc.mappingutils.io.MappingNamespace
import net.ornithemc.mappingutils.io.Mappings
import net.ornithemc.mappingutils.io.Mappings.ClassMapping
import net.ornithemc.mappingutils.io.Mappings.FieldMapping
import net.ornithemc.mappingutils.io.Mappings.MethodMapping
import net.ornithemc.mappingutils.io.Mappings.ParameterMapping
import net.ornithemc.mappingutils.io.MappingTarget
import net.ornithemc.mappingutils.io.MappingValidator
import net.ornithemc.mappingutils.io.diff.MappingsDiff
import net.ornithemc.mappingutils.io.diff.DiffSide
import net.ornithemc.mappingutils.io.diff.MappingsDiff.ClassDiff
import net.ornithemc.mappingutils.io.diff.MappingsDiff.Diff
import net.ornithemc.mappingutils.io.diff.MappingsDiff.FieldDiff
import net.ornithemc.mappingutils.io.diff.MappingsDiff.MethodDiff
import net.ornithemc.mappingutils.io.diff.MappingsDiff.ParameterDiff
import net.ornithemc.mappingutils.io.diff.MappingsDiffValidator
import net.ornithemc.mappingutils.io.diff.graph.VersionGraph
import net.ornithemc.nester.Nester
import net.ornithemc.nester.nest.NesterIo
import net.ornithemc.nester.nest.Nests
import org.apache.commons.io.FileUtils

buildscript {
	repositories {
		maven {
			name "Fabric Repository"
			url "https://maven.fabricmc.net"
		}
		maven {
			name "Quilt"
			url "https://maven.quiltmc.org/repository/release"
		}
		maven {
			name "Ornithe"
			url "https://maven.ornithemc.net/releases"
		}
		maven {
			name "Vineflower Snapshots"
			url "https://s01.oss.sonatype.org/content/repositories/snapshots/"
		}
		mavenCentral()
	}

	dependencies {
		classpath "net.ornithemc:tiny-remapper:0.8.4"
		classpath "net.ornithemc:enigma-cli:1.2.7"
		classpath "net.ornithemc:stitch:0.12.1"
		classpath "net.ornithemc:mapping-utils:0.9.2"
		classpath "commons-io:commons-io:2.8.0"
		classpath "org.codehaus.groovy:groovy-json:3.0.9"
		classpath "org.codehaus.groovy:groovy-xml:3.0.9"
	}
}

plugins {
	id 'de.undercouch.download' version '4.1.1'
	id 'java'
	id 'maven-publish'
}

repositories {
	mavenCentral()
	maven {
		name "Ornithe"
		url "https://maven.ornithemc.net/releases"
	}
	maven {
		name "Mojang"
		url 'https://libraries.minecraft.net/'
	}
	maven {
		name 'Quilt Repository'
		url 'https://maven.quiltmc.org/repository/release/'
	}
	maven {
		name 'Quilt Snapshot Repository'
		url 'https://maven.quiltmc.org/repository/snapshot/'
	}
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name "Procyon Repository"
		url 'https://oss.sonatype.org'
	}
	maven {
		name "Vineflower Snapshots"
		url 'https://s01.oss.sonatype.org/content/repositories/snapshots/'
	}
}

configurations {
	enigmaRuntime
}

dependencies {
	enigmaRuntime "net.ornithemc:enigma-swing:${project.enigma_version}"
	enigmaRuntime "org.quiltmc:quilt-enigma-plugin:${project.quilt_enigma_plugin_version}"
}

def ENV = System.getenv()

def jarSetupGroup = "jar setup"
def enigmaGroup = "enigma"
def buildMappingsGroup = "build mappings"
// cache dirs
def buildCacheDir = new File(project.gradle.gradleUserHomeDir, "caches/ornithe-cache")
def versionJsonsDir = new File(buildCacheDir, "version-jsons")
def gameJarsDir = new File(buildCacheDir, "game-jars")
def namedJarsDir = new File(buildCacheDir, "mapped-jars")
def nestedJarsDir = new File(buildCacheDir, "nested-jars")
def librariesDir = new File(buildCacheDir, "libraries")
def mappingsDir = new File(buildCacheDir, "mappings")
def nestsDir = new File(buildCacheDir, "nests")
def mappedNestsDir = new File(buildCacheDir, "mapped-nests")
// project dirs
def mappingsGraphDir = file("mappings");
def mappingsRunDir = file("run")

def minecraft_version = ENV.MC_VERSION
def intermediary_gen = 2

def manifestFile = new File(buildCacheDir, "version_manifest.json")
def versionInfo = null;
def versionDetails = null
def versionInfoFile = new File(versionJsonsDir, "${minecraft_version}-info.json")
def versionDetailsFile = new File(versionJsonsDir, "${minecraft_version}-details.json")
def clientJar = new File(gameJarsDir, "${minecraft_version}-client.jar")
def serverJar = new File(gameJarsDir, "${minecraft_version}-server.jar")
def mergedJar = new File(gameJarsDir, "${minecraft_version}-merged.jar")
def calamusClientJar = new File(namedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-client.jar")
def calamusServerJar = new File(namedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-server.jar")
def calamusMergedJar = new File(namedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}.jar")
def namedMergedJar = new File(namedJarsDir, "${minecraft_version}-feather-gen${intermediary_gen}.jar")
// only 1.8.2-pre4 and below need nests, but this information is not in the manifest
// on top of that, not all versions below 1.8.2-pre4 have nests available yet
def nesting = false
def nestedClientJar = new File(nestedJarsDir, "${minecraft_version}-nested-client.jar")
def nestedServerJar = new File(nestedJarsDir, "${minecraft_version}-nested-server.jar")
def nestedMergedJar = new File(nestedJarsDir, "${minecraft_version}-nested.jar")
def clientCalamusFile = new File(mappingsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-client.tiny")
def serverCalamusFile = new File(mappingsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-server.tiny")
def mergedCalamusFile = new File(mappingsDir, "${minecraft_version}-calamus-gen${intermediary_gen}.tiny")
def clientNestsFile = new File(nestsDir, "${minecraft_version}-client.nest")
def serverNestsFile = new File(nestsDir, "${minecraft_version}-server.nest")
def mergedNestsFile = new File(nestsDir, "${minecraft_version}.nest")
def calamusClientNestsFile = new File(mappedNestsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-client.nest")
def calamusServerNestsFile = new File(mappedNestsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-server.nest")
def calamusMergedNestsFile = new File(mappedNestsDir, "${minecraft_version}-calamus-gen${intermediary_gen}.nest")
def libraries = new ArrayList<File>()
def workingDir = new File(mappingsRunDir, "${minecraft_version}")

def artifact_id = "feather-gen${intermediary_gen}"

static void delete(Path p) {
	if (java.nio.file.Files.isDirectory(p)) {
		java.nio.file.Files.list(p).forEach(pp -> {
			delete(p)
		})
	}

	java.nio.file.Files.delete(p)
}

static boolean validateChecksum(File file, String checksum) {
	if (file != null) {
		//noinspection GrDeprecatedAPIUsage
		def hash = Files.asByteSource(file).hash(Hashing.sha1())
		def builder = new StringBuilder()
		hash.asBytes().each {
			builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
		}
		return builder.toString() == checksum
	}
	return false
}

task downloadVersionsManifest {
	group = jarSetupGroup

	//inputs.property "mc_ver", minecraft_version
	inputs.property "currenttime", new Date()
	outputs.file(manifestFile)

	doLast {
		logger.lifecycle(":downloading minecraft versions manifest")
		FileUtils.copyURLToFile(new URL("https://skyrising.github.io/mc-versions/version_manifest.json"), manifestFile)
	}
}

static def getManifestVersion(File manifestFile, String minecraft_version) {
	def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile, Charset.defaultCharset())) : null
	return manifest != null && minecraft_version != null ? manifest.versions.stream().filter({
		(it.id == minecraft_version)
	}).findFirst() : java.util.Optional.empty()
}

task downloadVersionInfo(dependsOn: downloadVersionsManifest) {
	group = jarSetupGroup

	outputs.files(versionInfoFile)

	doLast {
		def manifestVersion = getManifestVersion(manifestFile, minecraft_version)

		if (manifestVersion.isPresent() || versionInfoFile.exists()) {
			if (manifestVersion.isPresent()) {
				FileUtils.copyURLToFile(new URL(manifestVersion.get().url), versionInfoFile)
			}
		} else {
			throw new RuntimeException("No version info for Minecraft version ${minecraft_version} (Did you forget to set the MC_VERSION environment variable?)")
		}

		versionInfo = new JsonSlurper().parseText(FileUtils.readFileToString(versionInfoFile, Charset.defaultCharset()))
	}
}

task downloadVersionDetails(dependsOn: downloadVersionsManifest) {
	group = jarSetupGroup

	outputs.files(versionDetailsFile)

	doLast {
		def manifestVersion = getManifestVersion(manifestFile, minecraft_version)

		if (manifestVersion.isPresent() || versionDetailsFile.exists()) {
			if (manifestVersion.isPresent()) {
				FileUtils.copyURLToFile(new URL(manifestVersion.get().details), versionDetailsFile)
			}
		} else {
			throw new RuntimeException("No version details for Minecraft version ${minecraft_version} (Did you forget to set the MC_VERSION environment variable?)")
		}

		versionDetails = new JsonSlurper().parseText(FileUtils.readFileToString(versionDetailsFile, Charset.defaultCharset()))
	}
}

task downloadMcLibs(dependsOn: downloadVersionInfo) {
	group = jarSetupGroup

	inputs.files versionInfoFile
	outputs.dir(librariesDir)
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":downloading minecraft libraries")

		versionInfo.libraries.each {
			if (it.downloads == null) {
				return;
			}

			def artifact = it.downloads.artifact
			if (artifact == null) {
				return
			}
			def downloadUrl = artifact.url
			def libraryFile = new File(librariesDir, downloadUrl.substring(downloadUrl.lastIndexOf("/") + 1))

			download {
				src downloadUrl
				dest libraryFile
				overwrite false
			}

			libraries.add(libraryFile);
		}
	}
}

task downloadMcJars(dependsOn: downloadVersionDetails) {
	group = jarSetupGroup

	inputs.files versionDetailsFile
	outputs.files(clientJar, serverJar)
	outputs.upToDateWhen {
		if (project.gradle.startParameter.isRefreshDependencies()) {
			return false
		}
		def validClient = (!versionDetails.client || (clientJar.exists() && validateChecksum(clientJar, versionDetails.downloads.client.sha1)))
		def validServer = (!versionDetails.server || (serverJar.exists() && validateChecksum(serverJar, versionDetails.downloads.server.sha1)))

		return validClient && validServer
	}

	doLast {
		if (!versionDetailsFile.exists() || versionDetails == null) {
			throw new RuntimeException("Can't download the jars without the ${versionDetailsFile.name} file!")
		}

		logger.lifecycle(":downloading minecraft jar(s) for ${minecraft_version}")

		if (versionDetails.client) {
			download {
				src new URL(versionDetails.downloads.client.url)
				dest clientJar
				overwrite false
			}
		}
		if (versionDetails.server) {
			download {
				src new URL(versionDetails.downloads.server.url)
				dest serverJar
				overwrite false
			}
		}
	}
}

task mergeJars(dependsOn: downloadMcJars) {
	group = jarSetupGroup

	inputs.files downloadMcJars.outputs.files.files
	outputs.file(mergedJar)
	outputs.upToDateWhen {
		return false
	}

	doLast {
		if (versionDetails.sharedMappings) {
			logger.lifecycle(":merging jars")

			def jarMerger = new JarMerger(clientJar, serverJar, mergedJar)
			jarMerger.merge()
			jarMerger.close()
		}
	}
}

task downloadCalamus(dependsOn: downloadVersionDetails, type: Download) {
	group = jarSetupGroup

	src UrlEscapers.urlFragmentEscaper().escape("https://github.com/OrnitheMC/calamus/raw/gen${intermediary_gen}/mappings/${minecraft_version}.tiny")
	dest mergedCalamusFile

	doLast {
		if (!versionDetails.sharedMappings) {
			new CommandSplitTiny().run(
				mergedCalamusFile.getAbsolutePath(),
				clientCalamusFile.getAbsolutePath(),
				serverCalamusFile.getAbsolutePath()
			)
		}
	}
}

task mapCalamusJar(dependsOn: [downloadMcLibs, downloadCalamus, mergeJars]) {
	group = jarSetupGroup

	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(calamusMergedJar)
	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":mapping minecraft to calamus")

		if (versionDetails.sharedMappings && versionDetails.client && versionDetails.server) {
			mapJar(mergedJar, calamusMergedJar, mergedCalamusFile, libraries, "official", "intermediary")
		} else {
			if (versionDetails.client) {
				mapJar(clientJar, calamusClientJar, clientCalamusFile, libraries, "official", "intermediary")
			}
			if (versionDetails.server) {
				mapJar(serverJar, calamusServerJar, serverCalamusFile, libraries, "official", "intermediary")
			}
			if (versionDetails.client && versionDetails.server) {
				logger.lifecycle(":merging calamus jars")

				def jarMerger = new JarMerger(calamusClientJar, calamusServerJar, calamusMergedJar)
				jarMerger.merge()
				jarMerger.close()
			}
		}
	}
}

static void mapJar(File input, File output, File mappings, List<File> libraries, String from, String to, Action<TinyRemapper.Builder> action = {}) {
	if (output.exists()) {
		output.delete()
	}

	def remapperBuilder = TinyRemapper.newRemapper()
		.withMappings(TinyUtils.createTinyMappingProvider(mappings.toPath(), from, to))
		.renameInvalidLocals(true)
		.rebuildSourceFilenames(true)
	action.execute(remapperBuilder)
	def remapper = remapperBuilder.build()

	try {
		def outputConsumerBuilder = new OutputConsumerPath.Builder(output.toPath())
		def outputConsumer = outputConsumerBuilder.build()
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.readInputs(input.toPath())

		for (File library : libraries) {
			remapper.readClassPath(library.toPath())
		}
		remapper.apply(outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e)
	}
}

task downloadNests() {
	group = enigmaGroup

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		try {
			if (versionDetails.sharedMappings) {
				download {
					src new URL("https://github.com/OrnitheMC/nests/raw/main/nests/${minecraft_version}.nest")
					dest mergedNestsFile
					overwrite true
				}
			} else {
				if (versionDetails.client) {
					download {
						src new URL("https://github.com/OrnitheMC/nests/raw/main/nests/${minecraft_version}-client.nest")
						dest clientNestsFile
						overwrite true
					}
				}
				if (versionDetails.server) {
					download {
						src new URL("https://github.com/OrnitheMC/nests/raw/main/nests/${minecraft_version}-server.nest")
						dest serverNestsFile
						overwrite true
					}
				}
			}

			nesting = true
		} catch (NoSuchFileException ignored) {
			nesting = false
		}
		if (nesting) {
			if (versionDetails.sharedMappings) {
				mergedNestsFile = new File("/home/user/Documents/Development/Java/nests/nests/${minecraft_version}.nest")
			} else {
				if (versionDetails.client) {
					clientNestsFile = new File("/home/user/Documents/Development/Java/nests/nests/${minecraft_version}-client.nest")
				}
				if (versionDetails.server) {
					serverNestsFile = new File("/home/user/Documents/Development/Java/nests/nests/${minecraft_version}-server.nest")
				}
			}
		}
	}
}

task mapNests(dependsOn: [downloadNests, downloadCalamus]) {
	group = enigmaGroup

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		if (!nesting) {
			return
		}

		logger.lifecycle(":mapping nests to calamus")

		if (versionDetails.sharedMappings) {
			MappingUtils.mapNests(mergedNestsFile.toPath(), calamusMergedNestsFile.toPath(), Format.TINY_V1, mergedCalamusFile.toPath())
		} else {
			if (versionDetails.client) {
				MappingUtils.mapNests(clientNestsFile.toPath(), calamusClientNestsFile.toPath(), Format.TINY_V1, clientCalamusFile.toPath())
			}
			if (versionDetails.server) {
				MappingUtils.mapNests(serverNestsFile.toPath(), calamusServerNestsFile.toPath(), Format.TINY_V1, serverCalamusFile.toPath())
			}
			if (versionDetails.client && versionDetails.server) {
				logger.lifecycle(":merging calamus nests")

				MappingUtils.mergeNests(calamusClientNestsFile.toPath(), calamusServerNestsFile.toPath(), calamusMergedNestsFile.toPath())
			}
		}
	}
}

task nestJar(dependsOn: [mapCalamusJar, mapNests]) {
	group = enigmaGroup

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		if (!nesting) {
			return
		}

		logger.lifecycle(":nesting jar")

		if (versionDetails.client && versionDetails.server) {
			Nester.nestJar(new Nester.Options().silent(true), calamusMergedJar.toPath(), nestedMergedJar.toPath(), calamusMergedNestsFile.toPath())
		} else {
			if (versionDetails.client) {
				Nester.nestJar(new Nester.Options().silent(true), calamusClientJar.toPath(), nestedClientJar.toPath(), calamusClientNestsFile.toPath())
			}
			if (versionDetails.server) {
				Nester.nestJar(new Nester.Options().silent(true), calamusServerJar.toPath(), nestedServerJar.toPath(), calamusServerNestsFile.toPath())
			}
		}
	}
}

task separateMappings(dependsOn: mapNests) {
	group = enigmaGroup

	outputs.dirs(workingDir)
	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":separating mappings for ${minecraft_version}")

		VersionGraph graph = VersionGraph.of(Format.TINY_V2, mappingsGraphDir.toPath())
		Mappings mappings = MappingUtils.separateMappings(graph, minecraft_version)

		if (nesting) {
			Nests nests = Nests.empty()

			if (versionDetails.client && versionDetails.server) {
				NesterIo.read(nests, calamusMergedNestsFile.toPath())
			} else {
				if (versionDetails.client) {
					NesterIo.read(nests, calamusClientNestsFile.toPath())
				}
				if (versionDetails.server) {
					NesterIo.read(nests, calamusServerNestsFile.toPath())
				}
			}

			mappings = MappingUtils.applyNests(mappings, nests)
		}

		mappings.setValidator(new MappingValidator() {

			@Override
			public boolean validate(ClassMapping c) {
				if (!MappingsDiff.safeIsDiff(ClassMapping.getSimplified(c.src()), c.get()) && (c.get().startsWith("C_") || c.get().startsWith("net/minecraft/unmapped/C_"))) {
					c.set("");
					return !c.getJavadoc().isEmpty() || c.hasChildren();
				}

				return true;
			}

			@Override
			public boolean validate(FieldMapping f) {
				if (!MappingsDiff.safeIsDiff(f.src(), f.get()) && f.get().startsWith("f_")) {
					f.set("");
					return !f.getJavadoc().isEmpty();
				}

				return true;
			}

			@Override
			public boolean validate(MethodMapping m) {
				if (!MappingsDiff.safeIsDiff(m.src(), m.get()) && (m.get().startsWith("m_") || m.get().equals("<init>") || m.get().equals("<clinit>"))) {
					m.set("");
					return !m.getJavadoc().isEmpty() || m.hasChildren();
				}

				return true;
			}

			@Override
			public boolean validate(ParameterMapping p) {
				if (p.get().startsWith("p_")) {
					p.set("");
					return !p.getJavadoc().isEmpty();
				}

				return true;
			}
		})

		Format.ENIGMA_DIR.writeMappings(workingDir.toPath(), mappings)
	}
}

task enigma(dependsOn: [nestJar, separateMappings]) {
	group = enigmaGroup

	doLast {
		def jar = null

		if (versionDetails.client && versionDetails.server) {
			jar = nesting ? nestedMergedJar : calamusMergedJar
		} else {
			if (versionDetails.client) {
				jar = nesting ? nestedClientJar : calamusClientJar
			}
			if (versionDetails.server) {
				jar = nesting ? nestedServerJar : calamusServerJar
			}
		}

		ant.setLifecycleLogLevel "WARN"
		ant.java(
			classname: 'cuchaz.enigma.gui.Main',
			classpath: configurations.enigmaRuntime.asPath,
			fork: true,
			spawn: true
		) {
			jvmarg(value: "-Xmx2048m")
			arg(value: '-jar')
			arg(value: jar.getAbsolutePath())
			arg(value: '-mappings')
			arg(value: workingDir.getAbsolutePath())
			arg(value: '-profile')
			arg(value: 'enigma_profile.json')
		}
	}
}

task insertMappings(dependsOn: mapNests) {
	group = enigmaGroup

	doLast {
		logger.lifecycle(":saving mappings for ${minecraft_version}")

		insertMappings(minecraft_version, mappingsGraphDir, workingDir, calamusMergedNestsFile, PropagationDirection.NONE)
	}
}

task propagateMappingsDown(dependsOn: mapNests) {
	group = enigmaGroup

	doLast {
		logger.lifecycle(":saving mappings for ${minecraft_version}")

		insertMappings(minecraft_version, mappingsGraphDir, workingDir, calamusMergedNestsFile, PropagationDirection.DOWN)
	}
}

task propagateMappingsUp(dependsOn: mapNests) {
	group = enigmaGroup

	doLast {
		logger.lifecycle(":saving mappings for ${minecraft_version}")

		insertMappings(minecraft_version, mappingsGraphDir, workingDir, calamusMergedNestsFile, PropagationDirection.UP)
	}
}

task propagateMappings(dependsOn: mapNests) {
	group = enigmaGroup

	doLast {
		logger.lifecycle(":saving mappings for ${minecraft_version}")

		insertMappings(minecraft_version, mappingsGraphDir, workingDir, calamusMergedNestsFile, PropagationDirection.BOTH)
	}
}

static void insertMappings(String version_id, File mappingsGraphDir, File workingDir, File nestsFile, PropagationDirection dir) {
	VersionGraph graph = VersionGraph.of(Format.TINY_V2, mappingsGraphDir.toPath());

	Mappings separatedMappings = MappingUtils.separateMappings(graph, version_id);
	Mappings workingMappings = Format.ENIGMA_DIR.readMappings(workingDir.toPath());
	// enigma format does not have namespace info...
	workingMappings.setSrcNamespace(separatedMappings.getSrcNamespace())
	workingMappings.setDstNamespace(separatedMappings.getDstNamespace())

	if (nestsFile.exists()) {
		Nests nests = Nests.empty()
		NesterIo.read(nests, nestsFile.toPath())

		workingMappings = MappingUtils.undoNests(workingMappings, nests)
	}

	MappingsDiff changes = MappingUtils.diffMappings(separatedMappings, workingMappings);

	changes.setValidator(new MappingsDiffValidator() {

		@Override
		public boolean validate(ClassDiff c) {
			return check(c);
		}

		@Override
		public boolean validate(FieldDiff f) {
			return check(f);
		}

		@Override
		public boolean validate(MethodDiff m) {
			return check(m);
		}

		@Override
		public boolean validate(ParameterDiff p) {
			return check(p);
		}

		private boolean check(Diff d) {
			if (d.isDiff()) {
				if (d.get(DiffSide.A).isEmpty()) {
					// new mappings should be ignored, as any un-mapped members
					// should already be present as dummy mappings
					System.out.println("ignoring illegal change " + d);
					return false;
				}
				if (d.get(DiffSide.B).isEmpty()) {
					// removing a mapping is changed into a dummy mapping
					if (d.target() == MappingTarget.CLASS) {
						d.set(DiffSide.B, ClassMapping.getSimplified(d.src()));
					} else if (d.target() == MappingTarget.PARAMETER) {
						d.set(DiffSide.B, "p_" + ((ParameterDiff)d).getIndex());
					} else {
						d.set(DiffSide.B, d.src());
					}
				}
			}

			return true;
		}
	});

	PropagationOptions options = new PropagationOptions.Builder().setPropagationDirection(dir).lenient().build();
	MappingUtils.insertMappings(options, graph, changes, version_id);

	delete(workingDir)
}

static void generateDummyMappings(File jar, File map) {
	MappingUtils.generateDummyMappings(Format.TINY_V2, MappingNamespace.INTERMEDIARY, MappingNamespace.NAMED, "^(net/minecraft/|com/mojang/).*\$", jar.toPath(), map.toPath())
}

static void diffDummyMappings(File a, File b, File d) {
	MappingUtils.diffMappings(Format.TINY_V2, a.toPath(), b.toPath(), d.toPath())
}

static void insertMappingChanges(VersionGraph graph, MappingsDiff changes, String version) {
	MappingUtils.insertMappings(new PropagationOptions.Builder().lenient().build(), graph, changes, version)
}

task resetGraph(dependsOn: mapCalamusJar) {
	group = enigmaGroup

	outputs.dir(mappingsGraphDir)
	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle("resetting mapping graph with ${minecraft_version} as the root")

		def jar = null

		if (versionDetails.client && versionDetails.server) {
			jar = calamusMergedJar
		} else {
			if (versionDetails.client) {
				jar = calamusClientJar
			}
			if (versionDetails.server) {
				jar = calamusServerJar
			}
		}

		def map = new File(mappingsGraphDir, "${minecraft_version}.tiny")

		if (mappingsGraphDir.exists()) {
			delete(mappingsGraphDir)
		}
		mappingsGraphDir.mkdirs()

		generateDummyMappings(jar, map)
	}
}

task extendGraph(dependsOn: mapCalamusJar) {
	group = enigmaGroup

	outputs.dir(mappingsGraphDir)
	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		def from_minecraft_version = ENV.FROM_MC_VERSION

		if (from_minecraft_version == null) {
			throw new RuntimeException("cannot extend graph: FROM_MC_VERSION environment variable is not set!")
		}

		VersionGraph graph = VersionGraph.of(Format.TINY_V2, mappingsGraphDir.toPath())

		if (!graph.hasVersion(from_minecraft_version)) {
			throw new RuntimeException("cannot extend graph from ${from_minecraft_version}: version does not exist in the graph!")
		}

		def jar = null

		if (versionDetails.client && versionDetails.server) {
			jar = calamusMergedJar
		} else {
			if (versionDetails.client) {
				jar = calamusClientJar
			}
			if (versionDetails.server) {
				jar = calamusServerJar
			}
		}

		def fromJar = new File(jar.parentFile, "${from_minecraft_version}-calamus-gen${intermediary_gen}.jar")

		if (!java.nio.file.Files.exists(fromJar.toPath())) {
			throw new RuntimeException("cannot extend graph from ${from_minecraft_version}: no calamus mapped merged jar found!")
		}

		logger.lifecycle("extending mapping graph from ${from_minecraft_version} to ${minecraft_version}")

		File tmpGraphDir = file(".mappings")
		File fromDummy = new File(tmpGraphDir, "${from_minecraft_version}.tiny")
		File dummy = new File(tmpGraphDir, "${minecraft_version}")
		File diff = new File(mappingsGraphDir, "${from_minecraft_version}#${minecraft_version}.tinydiff")
		File tmpDiff = new File(tmpGraphDir, "${from_minecraft_version}#${minecraft_version}.tinydiff")

		delete(tmpGraphDir)
		tmpGraphDir.mkdirs()

		generateDummyMappings(fromJar, fromDummy)
		generateDummyMappings(jar, dummy)
		diffDummyMappings(fromDummy, dummy, tmpDiff);

		delete(dummy)

		VersionGraph tmpGraph = VersionGraph.of(Format.TINY_V2, tmpGraphDir.toPath())

		Mappings mappings = MappingUtils.separateMappings(graph, from_minecraft_version)
		Mappings tmpMappings = MappingUtils.separateMappings(tmpGraph, from_minecraft_version)
		MappingsDiff changes = MappingUtils.diffMappings(tmpMappings, mappings)

		insertMappingChanges(tmpGraph, changes, from_minecraft_version)

		java.nio.file.Files.copy(tmpDiff.toPath(), diff.toPath())

		delete(tmpGraphDir)
	}
}
/*
 static List<String> getPublishedVersions(def artifact_id) {
 def xml = new URL("https://maven.ornithemc.net/releases/net/ornithemc/${artifact_id}/maven-metadata.xml").text
 def metadata = new XmlSlurper().parseText(xml)
 def versions = metadata.versioning.versions.version*.text()
 return versions
 }
 def publishedVersions
 try {
 publishedVersions = getPublishedVersions(artifact_id)
 } catch (ignored) {
 }
 def localMappingsPath = "$buildDir/v2Mappings"
 new File(localMappingsPath).mkdirs()
 file('mappings').eachFile {
 if (!it.name.endsWith(".tiny")) {
 return
 }
 def mcVer = it.name.replace(".tiny", "")
 if (publishedVersions != null && publishedVersions.contains(mcVer)) {
 return
 }
 File v1MappingFile = it
 File v2MappingFile = new File("$localMappingsPath/${it.name}")
 def conversionTask = "convert${it.name}ToV2"
 tasks.register(conversionTask) {
 group = "V2 Conversion"
 inputs.file(v1MappingFile)
 outputs.file(v2MappingFile)
 doLast {
 new ConvertMappingsCommand().run(
 "tiny",
 v1MappingFile.path,
 versionDetails.sharedMappings ? "tinyv2:${namespace}:clientOfficial:serverOfficial" : "tinyv2:official:${namespace}",
 v2MappingFile.path
 )
 }
 }
 Jar makeV1Jar = makeJar(mcVer, v1MappingFile, false)
 Jar makeV2Jar = makeJar(mcVer, v2MappingFile, true)
 build.dependsOn makeV1Jar
 build.dependsOn makeV2Jar
 makeV2Jar.dependsOn conversionTask
 publishing {
 publications {
 create("${mcVer.replace(" ", "")}_mavenJava", MavenPublication) {
 groupId 'net.ornithemc'
 artifactId artifact_id
 version mcVer
 artifact(makeV1Jar.archiveFile) {
 builtBy makeV1Jar
 }
 artifact(makeV2Jar.archiveFile) {
 builtBy makeV2Jar
 classifier = "v2"
 }
 }
 }
 }
 }
 def makeJar(String mcVersion, File mappings, boolean v2) {
 def jarFilename = "calamus-" + mcVersion + (v2 ? "-v2" : "")
 return task("${mcVersion}_makeJar" + (v2 ? "v2" : ""), type: Jar) {
 archiveBaseName.set(jarFilename)
 from(file(mappings)) {
 into "mappings"
 rename mappings.name, "mappings.tiny"
 }
 destinationDirectory = file("build/jars")
 }
 }
 publishing {
 repositories {
 if (ENV.MAVEN_URL) {
 maven {
 url ENV.MAVEN_URL
 credentials {
 username ENV.MAVEN_USERNAME
 password ENV.MAVEN_PASSWORD
 }
 authentication {
 basic(BasicAuthentication)
 }
 }
 }
 }
 }
 */