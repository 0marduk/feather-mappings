import java.nio.charset.Charset
import java.nio.file.NoSuchFileException
import java.nio.file.StandardCopyOption
import java.util.List
import groovy.json.JsonSlurper

import com.google.common.io.Files
import com.google.common.hash.Hashing
import com.google.common.net.UrlEscapers
import cuchaz.enigma.command.ConvertMappingsCommand
import io.github.gaming32.signaturechanger.cli.ApplyAction
import net.fabricmc.stitch.commands.CommandSplitTiny
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils
import net.ornithemc.mappingutils.MappingUtils
import net.ornithemc.mappingutils.PropagationDirection
import net.ornithemc.mappingutils.PropagationOptions
import net.ornithemc.mappingutils.io.Format
import net.ornithemc.mappingutils.io.MappingNamespace
import net.ornithemc.mappingutils.io.Mappings
import net.ornithemc.mappingutils.io.Mappings.ClassMapping
import net.ornithemc.mappingutils.io.Mappings.FieldMapping
import net.ornithemc.mappingutils.io.Mappings.MethodMapping
import net.ornithemc.mappingutils.io.Mappings.ParameterMapping
import net.ornithemc.mappingutils.io.MappingTarget
import net.ornithemc.mappingutils.io.MappingValidator
import net.ornithemc.mappingutils.io.diff.MappingsDiff
import net.ornithemc.mappingutils.io.diff.DiffSide
import net.ornithemc.mappingutils.io.diff.MappingsDiff.ClassDiff
import net.ornithemc.mappingutils.io.diff.MappingsDiff.Diff
import net.ornithemc.mappingutils.io.diff.MappingsDiff.FieldDiff
import net.ornithemc.mappingutils.io.diff.MappingsDiff.MethodDiff
import net.ornithemc.mappingutils.io.diff.MappingsDiff.ParameterDiff
import net.ornithemc.mappingutils.io.diff.MappingsDiffValidator
import net.ornithemc.mappingutils.io.diff.graph.VersionGraph
import net.ornithemc.nester.Nester
import net.ornithemc.nester.nest.NesterIo
import net.ornithemc.nester.nest.Nests
import org.apache.commons.io.FileUtils

buildscript {
	repositories {
		maven {
			name "Fabric Repository"
			url "https://maven.fabricmc.net"
		}
		maven {
			name "Quilt"
			url "https://maven.quiltmc.org/repository/release"
		}
		maven {
			name "Ornithe"
			url "https://maven.ornithemc.net/releases"
		}
		maven {
			name "Vineflower Snapshots"
			url "https://s01.oss.sonatype.org/content/repositories/snapshots/"
		}
		mavenCentral()
	}

	dependencies {
		classpath "net.fabricmc:tiny-remapper:0.9.0"
		classpath "net.ornithemc:enigma-cli:1.2.7"
		classpath "net.ornithemc:stitch:0.15.4"
		classpath "net.ornithemc:mapping-utils:0.10.3"
		classpath "io.github.gaming32:signature-changer:1.0.0-beta.1"
		classpath "commons-io:commons-io:2.8.0"
		classpath "org.codehaus.groovy:groovy-json:3.0.9"
		classpath "org.codehaus.groovy:groovy-xml:3.0.9"
	}
}

plugins {
	id 'de.undercouch.download' version '4.1.1'
	id 'java'
	id 'maven-publish'
}

repositories {
	mavenCentral()
	maven {
		name "Ornithe"
		url "https://maven.ornithemc.net/releases"
	}
	maven {
		name "Mojang"
		url 'https://libraries.minecraft.net/'
	}
	maven {
		name 'Quilt Repository'
		url 'https://maven.quiltmc.org/repository/release/'
	}
	maven {
		name 'Quilt Snapshot Repository'
		url 'https://maven.quiltmc.org/repository/snapshot/'
	}
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name "Procyon Repository"
		url 'https://oss.sonatype.org'
	}
	maven {
		name "Vineflower Snapshots"
		url 'https://s01.oss.sonatype.org/content/repositories/snapshots/'
	}
}

configurations {
	enigmaRuntime
}

dependencies {
	enigmaRuntime "net.ornithemc:enigma-swing:${project.enigma_version}"
	enigmaRuntime "org.quiltmc:quilt-enigma-plugin:${project.quilt_enigma_plugin_version}"
}

def ENV = System.getenv()

def jarSetupGroup = "jar setup"
def enigmaGroup = "enigma"
def buildMappingsGroup = "build mappings"
// cache dirs
def buildCacheDir = new File(project.gradle.gradleUserHomeDir, "caches/ornithe-cache")
def versionJsonsDir = new File(buildCacheDir, "version-jsons")
def gameJarsDir = new File(buildCacheDir, "game-jars")
def mappedJarsDir = new File(buildCacheDir, "mapped-jars")
def processedJarsDir = new File(buildCacheDir, "processed-jars")
def librariesDir = new File(buildCacheDir, "libraries")
def mappingsDir = new File(buildCacheDir, "mappings")
def processedMappingsDir = new File(buildCacheDir, "processed-mappings")
def nestsDir = new File(buildCacheDir, "nests")
def sparrowDir = new File(buildCacheDir, "sparrow")
// project dirs
def mappingsGraphDir = file("mappings");
def mappingsRunDir = file("run")

def minecraft_version = ENV.MC_VERSION
def from_minecraft_version = ENV.FROM_MC_VERSION
def from_from_minecraft_version = ENV.FROM_FROM_MC_VERSION
def intermediary_gen = 2

def manifestFile = new File(buildCacheDir, "version_manifest.json")
def versionInfo = null;
def versionDetails = null
def versionInfoFile = new File(versionJsonsDir, "${minecraft_version}-info.json")
def versionDetailsFile = new File(versionJsonsDir, "${minecraft_version}-details.json")
def clientJar = new File(gameJarsDir, "${minecraft_version}-client.jar")
def serverJar = new File(gameJarsDir, "${minecraft_version}-server.jar")
def mergedJar = new File(gameJarsDir, "${minecraft_version}.jar")
def calamusClientJar = new File(mappedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-client.jar")
def calamusServerJar = new File(mappedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-server.jar")
def calamusMergedJar = new File(mappedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}.jar")
def featherMergedJar = new File(mappedJarsDir, "${minecraft_version}-feather-gen${intermediary_gen}.jar")
// only 1.8.2-pre4 and below need nests, but this information is not in the manifest
// on top of that, not all versions below 1.8.2-pre4 have nests available yet
def nesting = false
def nestedClientJar = new File(processedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-nested-client.jar")
def nestedServerJar = new File(processedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-nested-server.jar")
def nestedMergedJar = new File(processedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-nested.jar")
// only 1.8.2-pre4 and below need signature patching, but this information is not in the manifest
// on top of that, not all versions below 1.8.2-pre4 have signature patches available yet
def signaturePatching = false
def signaturePatchedClientJar = new File(processedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-signature-patched-client.jar")
def signaturePatchedServerJar = new File(processedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-signature-patched-server.jar")
def signaturePatchedMergedJar = new File(processedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-signature-patched.jar")
def processedClientJar = new File(processedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-processed-client.jar")
def processedServerJar = new File(processedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-processed-server.jar")
def processedMergedJar = new File(processedJarsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-processed.jar")
def clientCalamusFile = new File(mappingsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-client.tiny")
def serverCalamusFile = new File(mappingsDir, "${minecraft_version}-calamus-gen${intermediary_gen}-server.tiny")
def mergedCalamusFile = new File(mappingsDir, "${minecraft_version}-calamus-gen${intermediary_gen}.tiny")
def nestedClientCalamusFile = new File(processedMappingsDir, "${minecraft_version}-nested-calamus-gen${intermediary_gen}-client.tiny")
def nestedServerCalamusFile = new File(processedMappingsDir, "${minecraft_version}-nested-calamus-gen${intermediary_gen}-server.tiny")
def nestedMergedCalamusFile = new File(processedMappingsDir, "${minecraft_version}-nested-calamus-gen${intermediary_gen}.tiny")
def clientNestsFile = new File(nestsDir, "${minecraft_version}-client.nest")
def serverNestsFile = new File(nestsDir, "${minecraft_version}-server.nest")
def mergedNestsFile = new File(nestsDir, "${minecraft_version}.nest")
def calamusClientNestsFile = new File(nestsDir, "${minecraft_version}-calamus-gen-${intermediary_gen}-client.nest")
def calamusServerNestsFile = new File(nestsDir, "${minecraft_version}-calamus-gen-${intermediary_gen}-server.nest")
def calamusMergedNestsFile = new File(nestsDir, "${minecraft_version}-calamus-gen-${intermediary_gen}.nest")
def clientSparrowFile = new File(sparrowDir, "${minecraft_version}-client.sigs")
def serverSparrowFile = new File(sparrowDir, "${minecraft_version}-server.sigs")
def mergedSparrowFile = new File(sparrowDir, "${minecraft_version}.sigs")
def calamusClientSparrowFile = new File(sparrowDir, "${minecraft_version}-calamus-gen-${intermediary_gen}-client.sigs")
def calamusServerSparrowFile = new File(sparrowDir, "${minecraft_version}-calamus-gen-${intermediary_gen}-server.sigs")
def calamusMergedSparrowFile = new File(sparrowDir, "${minecraft_version}-calamus-gen-${intermediary_gen}.sigs")
def libraries = new ArrayList<File>()
def workingDir = new File(mappingsRunDir, "${minecraft_version}")

// used for extending the graph
def fromVersionInfo = null;
def fromVersionDetails = null
def fromVersionInfoFile = new File(versionJsonsDir, "${from_minecraft_version}-info.json")
def fromVersionDetailsFile = new File(versionJsonsDir, "${from_minecraft_version}-details.json")
def fromCalamusClientJar = new File(mappedJarsDir, "${from_minecraft_version}-calamus-gen${intermediary_gen}-client.jar")
def fromCalamusServerJar = new File(mappedJarsDir, "${from_minecraft_version}-calamus-gen${intermediary_gen}-server.jar")
def fromCalamusMergedJar = new File(mappedJarsDir, "${from_minecraft_version}-calamus-gen${intermediary_gen}.jar")
def fromFromVersionInfo = null;
def fromFromVersionDetails = null
def fromFromVersionInfoFile = new File(versionJsonsDir, "${from_from_minecraft_version}-info.json")
def fromFromVersionDetailsFile = new File(versionJsonsDir, "${from_from_minecraft_version}-details.json")
def fromFromCalamusClientJar = new File(mappedJarsDir, "${from_from_minecraft_version}-calamus-gen${intermediary_gen}-client.jar")
def fromFromCalamusServerJar = new File(mappedJarsDir, "${from_from_minecraft_version}-calamus-gen${intermediary_gen}-server.jar")
def fromFromCalamusMergedJar = new File(mappedJarsDir, "${from_from_minecraft_version}-calamus-gen${intermediary_gen}.jar")

def artifact_id = "feather-gen${intermediary_gen}"

static def pickSide(def details, def merged, def client, def server) {
	if (details.client && details.server) {
		return merged
	} else {
		if (details.client)
			return client
		if (details.server)
			return server
	}
	throw new IllegalStateException("Minecraft ${details.id} is neither client nor server???")
}

static def pickEnv(def details, def merged, def client, def server) {
	if (details.sharedMappings) {
		return merged
	} else {
		if (details.client)
			return client
		if (details.server)
			return server
	}
	throw new IllegalStateException("Minecraft ${details.id} is neither merged, client, nor server???")
}

static void delete(Path p) {
	if (java.nio.file.Files.isDirectory(p)) {
		java.nio.file.Files.list(p).forEach(pp -> {
			delete(p)
		})
	}

	java.nio.file.Files.delete(p)
}

static boolean validateChecksum(File file, String checksum) {
	if (file != null) {
		//noinspection GrDeprecatedAPIUsage
		def hash = Files.asByteSource(file).hash(Hashing.sha1())
		def builder = new StringBuilder()
		hash.asBytes().each {
			builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
		}
		return builder.toString() == checksum
	}
	return false
}

task downloadVersionsManifest {
	group = jarSetupGroup

	//inputs.property "mc_ver", minecraft_version
	inputs.property "currenttime", new Date()
	outputs.file(manifestFile)

	doLast {
		logger.lifecycle(":downloading minecraft versions manifest")
		FileUtils.copyURLToFile(new URL("https://skyrising.github.io/mc-versions/version_manifest.json"), manifestFile)
	}
}

static def getManifestVersion(File manifestFile, String minecraft_version) {
	def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile, Charset.defaultCharset())) : null
	return manifest != null && minecraft_version != null ? manifest.versions.stream().filter({
		(it.id == minecraft_version)
	}).findFirst() : java.util.Optional.empty()
}

def getVersionInfo(def version, def file, def minecraft_version, def env_var) {
	if (version.isPresent() || file.exists()) {
		if (version.isPresent()) {
			FileUtils.copyURLToFile(new URL(version.get().url), file)
		}
	} else {
		throw new RuntimeException("No version info for Minecraft version ${minecraft_version} (Did you forget to set the ${env_var} environment variable?)")
	}

	return new JsonSlurper().parseText(FileUtils.readFileToString(file, Charset.defaultCharset()))
}

task downloadVersionInfo(dependsOn: downloadVersionsManifest) {
	group = jarSetupGroup

	outputs.files(versionInfoFile)
	outputs.upToDateWhen { false }

	doLast {
		def manifestVersion = getManifestVersion(manifestFile, minecraft_version)
		def fromManifestVersion = getManifestVersion(manifestFile, from_minecraft_version)
		def fromFromManifestVersion = getManifestVersion(manifestFile, from_from_minecraft_version)

		versionInfo = getVersionInfo(manifestVersion, versionInfoFile, minecraft_version, "MC_VERSION")
		if (from_minecraft_version != null) {
			fromVersionInfo = getVersionInfo(fromManifestVersion, fromVersionInfoFile, from_minecraft_version, "FROM_MC_VERSION")
			if (from_from_minecraft_version != null) {
				fromFromVersionInfo = getVersionInfo(fromFromManifestVersion, fromFromVersionInfoFile, from_from_minecraft_version, "FROM_FROM_MC_VERSION")
			}
		}
	}
}

def getVersionDetails(def version, def file, def minecraft_version, def env_var) {
	if (version.isPresent() || file.exists()) {
		if (version.isPresent()) {
			FileUtils.copyURLToFile(new URL(version.get().details), file)
		}
	} else {
		throw new RuntimeException("No version details for Minecraft version ${minecraft_version} (Did you forget to set the ${env_var} environment variable?)")
	}

	return new JsonSlurper().parseText(FileUtils.readFileToString(file, Charset.defaultCharset()))
}

task downloadVersionDetails(dependsOn: downloadVersionsManifest) {
	group = jarSetupGroup

	outputs.files(versionDetailsFile)
	outputs.upToDateWhen { false }

	doLast {
		def manifestVersion = getManifestVersion(manifestFile, minecraft_version)
		def fromManifestVersion = getManifestVersion(manifestFile, from_minecraft_version)
		def fromFromManifestVersion = getManifestVersion(manifestFile, from_from_minecraft_version)

		versionDetails = getVersionDetails(manifestVersion, versionDetailsFile, minecraft_version, "MC_VERSION")
		if (from_minecraft_version != null) {
			fromVersionDetails = getVersionDetails(fromManifestVersion, fromVersionDetailsFile, from_minecraft_version, "FROM_MC_VERSION")
			if (from_from_minecraft_version != null) {
				fromFromVersionDetails = getVersionDetails(fromFromManifestVersion, fromFromVersionDetailsFile, from_from_minecraft_version, "FROM_FROM_MC_VERSION")
			}
		}
	}
}

task downloadMcLibs(dependsOn: downloadVersionInfo) {
	group = jarSetupGroup

	inputs.files versionInfoFile
	outputs.dir(librariesDir)
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":downloading minecraft libraries")

		versionInfo.libraries.each {
			if (it.downloads == null) {
				return;
			}

			def artifact = it.downloads.artifact
			if (artifact == null) {
				return
			}
			def downloadUrl = artifact.url
			def checksum = artifact.sha1
			def libraryFile = new File(librariesDir, downloadUrl.substring(downloadUrl.lastIndexOf("/") + 1))

			if (!libraryFile.exists() || !validateChecksum(libraryFile, checksum)) {
				project.download {
					src downloadUrl
					dest libraryFile
					overwrite true
				}
			}

			libraries.add(libraryFile)
		}
	}
}

task downloadMcJars(dependsOn: downloadVersionDetails) {
	group = jarSetupGroup

	inputs.files versionDetailsFile
	outputs.files(clientJar, serverJar)
	outputs.upToDateWhen {
		if (project.gradle.startParameter.isRefreshDependencies()) {
			return false
		}
		def validClient = (!versionDetails.client || (clientJar.exists() && validateChecksum(clientJar, versionDetails.downloads.client.sha1)))
		def validServer = (!versionDetails.server || (serverJar.exists() && validateChecksum(serverJar, versionDetails.downloads.server.sha1)))

		return validClient && validServer
	}

	doLast {
		if (!versionDetailsFile.exists() || versionDetails == null) {
			throw new RuntimeException("Can't download the jars without the ${versionDetailsFile.name} file!")
		}

		logger.lifecycle(":downloading minecraft jar(s) for ${minecraft_version}")

		if (versionDetails.client) {
			download {
				src new URL(versionDetails.downloads.client.url)
				dest clientJar
				overwrite false
			}
		}
		if (versionDetails.server) {
			download {
				src new URL(versionDetails.downloads.server.url)
				dest serverJar
				overwrite false
			}
		}
	}
}

task mergeMcJars(dependsOn: downloadMcJars) {
	group = jarSetupGroup

	inputs.files downloadMcJars.outputs.files.files
	outputs.file(mergedJar)
	outputs.upToDateWhen { false }

	doLast {
		if (versionDetails.sharedMappings && versionDetails.client && versionDetails.server) {
			logger.lifecycle(":merging obfuscated jars")

			def jarMerger = new JarMerger(clientJar, serverJar, mergedJar)
			jarMerger.merge()
			jarMerger.close()
		}
	}
}

task downloadIntermediary(dependsOn: downloadVersionDetails, type: Download) {
	group = jarSetupGroup

	src UrlEscapers.urlFragmentEscaper().escape("https://github.com/OrnitheMC/calamus/raw/gen${intermediary_gen}/mappings/${minecraft_version}.tiny")
	dest mergedCalamusFile

	doLast {
		if (!versionDetails.sharedMappings) {
			boolean clientMissing = (versionDetails.client && !clientCalamusFile.exists())
			boolean serverMissing = (versionDetails.server && !serverCalamusFile.exists())

			if (clientMissing || serverMissing) {
				new CommandSplitTiny().run(
					mergedCalamusFile.getAbsolutePath(),
					versionDetails.client ? clientCalamusFile.getAbsolutePath() : "-",
					versionDetails.server ? serverCalamusFile.getAbsolutePath() : "-"
				)
			}
		}
	}
}

task mapMcJarsToIntermediary(dependsOn: [downloadMcLibs, downloadIntermediary, mergeMcJars]) {
	group = jarSetupGroup

	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(calamusMergedJar)
	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":mapping minecraft to intermediary")

		if (versionDetails.sharedMappings) {
			def jarIn = pickSide(versionDetails, mergedJar, clientJar, serverJar)
			def jarOut = pickSide(versionDetails, calamusMergedJar, calamusClientJar, calamusServerJar)
			
			mapJar(jarIn, jarOut, mergedCalamusFile, libraries, "official", "intermediary")
		} else {
			if (versionDetails.client) {
				mapJar(clientJar, calamusClientJar, clientCalamusFile, libraries, "official", "intermediary")
			}
			if (versionDetails.server) {
				mapJar(serverJar, calamusServerJar, serverCalamusFile, libraries, "official", "intermediary")
			}
			if (versionDetails.client && versionDetails.server) {
				// only reached when sharedMappings is false
				logger.lifecycle(":merging intermediary jars")

				def jarMerger = new JarMerger(calamusClientJar, calamusServerJar, calamusMergedJar)
				jarMerger.merge()
				jarMerger.close()
			}
		}
	}
}

static void mapJar(File input, File output, File mappings, List<File> libraries, String from, String to, Action<TinyRemapper.Builder> action = {}) {
	if (output.exists()) {
		output.delete()
	}

	def remapperBuilder = TinyRemapper.newRemapper()
		.withMappings(TinyUtils.createTinyMappingProvider(mappings.toPath(), from, to))
		.renameInvalidLocals(true)
		.rebuildSourceFilenames(true)
	action.execute(remapperBuilder)
	def remapper = remapperBuilder.build()

	try {
		def outputConsumerBuilder = new OutputConsumerPath.Builder(output.toPath())
		def outputConsumer = outputConsumerBuilder.build()
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.readInputs(input.toPath())

		for (File library : libraries) {
			remapper.readClassPath(library.toPath())
		}
		remapper.apply(outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e)
	}
}

void downloadNests(def version, def file) {
	project.download {
		src new URL("https://github.com/OrnitheMC/nests/raw/main/nests/${version}.nest")
		dest file
		overwrite true
	}
}

task downloadNests(dependsOn: downloadVersionDetails) {
	group = enigmaGroup

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		try {
			if (versionDetails.sharedMappings) {
				downloadNests(minecraft_version, mergedNestsFile)
			} else {
				if (versionDetails.client) {
					downloadNests("${minecraft_version}-client", clientNestsFile)
				}
				if (versionDetails.server) {
					downloadNests("${minecraft_version}-server", serverNestsFile)
				}
			}

			nesting = true
		} catch (Throwable ignored) {
			nesting = false
		}
	}
}

task mapNestsToIntermediary(dependsOn: [downloadNests, downloadIntermediary]) {
	group = enigmaGroup

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		if (nesting) {
			logger.lifecycle(":mapping nests to intermediary")

			if (versionDetails.sharedMappings) {
				MappingUtils.mapNests(mergedNestsFile.toPath(), calamusMergedNestsFile.toPath(), Format.TINY_V1, mergedCalamusFile.toPath())
			} else {
				if (versionDetails.client) {
					MappingUtils.mapNests(clientNestsFile.toPath(), calamusClientNestsFile.toPath(), Format.TINY_V1, clientCalamusFile.toPath())
				}
				if (versionDetails.server) {
					MappingUtils.mapNests(serverNestsFile.toPath(), calamusServerNestsFile.toPath(), Format.TINY_V1, serverCalamusFile.toPath())
				}
				if (versionDetails.client && versionDetails.server) {
					logger.lifecycle(":merging intermediary nests")

					MappingUtils.mergeNests(calamusClientNestsFile.toPath(), calamusServerNestsFile.toPath(), calamusMergedNestsFile.toPath())
				}
			}
		}
	}
}

task applyNestsToIntermediary(dependsOn: mapNestsToIntermediary) {
	group = enigmaGroup
	
	inputs.files downloadIntermediary.outputs.files.files
	outputs.file(nestedMergedCalamusFile)
	outputs.upToDateWhen { false }

	doLast {
		if (nesting) {
			logger.lifecycle(":applying nests to intermediary")

			def calamus = pickEnv(versionDetails, mergedCalamusFile.toPath(), clientCalamusFile.toPath(), serverCalamusFile.toPath())
			def nestedCalamus = pickEnv(versionDetails, nestedMergedCalamusFile.toPath(), nestedClientCalamusFile.toPath(), nestedServerCalamusFile.toPath())
			def nests = pickEnv(versionDetails, calamusMergedNestsFile.toPath(), calamusClientNestsFile.toPath(), calamusServerNestsFile.toPath())

			MappingUtils.applyNests(Format.TINY_V1, calamus, nestedCalamus, nests)
		}
	}
}

void downloadSignatures(def version, def file) {
	project.download {
		src new URL("https://github.com/OrnitheMC/sparrow/raw/main/signatures/${version}.sigs")
		dest file
		overwrite true
	}
}

task downloadSignatures(dependsOn: downloadVersionDetails) {
	group = enigmaGroup

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		try {
			if (versionDetails.sharedMappings) {
				downloadSignatures(minecraft_version, mergedSparrowFile)
			} else {
				if (versionDetails.client) {
					downloadSignatures("${minecraft_version}-client", clientSparrowFile)
				}
				if (versionDetails.server) {
					downloadSignatures("${minecraft_version}-server", serverSparrowFile)
				}
			}

			signaturePatching = true
		} catch (Throwable ignored) {
			signaturePatching = false
		}
	}
}

task mapSignaturesToIntermediary(dependsOn: [downloadSignatures, applyNestsToIntermediary]) {
	group = enigmaGroup

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		if (signaturePatching) {
			logger.lifecycle(":mapping signatures to intermediary")

			if (versionDetails.sharedMappings) {
				MappingUtils.mapSignatures(mergedSparrowFile.toPath(), calamusMergedSparrowFile.toPath(), Format.TINY_V1, nesting ? nestedMergedCalamusFile.toPath() : mergedCalamusFile.toPath())
			} else {
				if (versionDetails.client) {
					MappingUtils.mapSignatures(clientSparrowFile.toPath(), calamusClientSparrowFile.toPath(), Format.TINY_V1, nesting ? nestedClientCalamusFile.toPath() : clientCalamusFile.toPath())
				}
				if (versionDetails.server) {
					MappingUtils.mapSignatures(serverSparrowFile.toPath(), calamusServerSparrowFile.toPath(), Format.TINY_V1, nesting ? nestedServerCalamusFile.toPath() : serverCalamusFile.toPath())
				}
				if (versionDetails.client && versionDetails.server) {
					logger.lifecycle(":merging intermediary signatures")

					MappingUtils.mergeSignatures(calamusClientSparrowFile.toPath(), calamusServerSparrowFile.toPath(), calamusMergedSparrowFile.toPath())
				}
			}
		}
	}
}

task processMcJars(dependsOn: [mapMcJarsToIntermediary, mapNestsToIntermediary, mapSignaturesToIntermediary]) {
	group = enigmaGroup
	
	inputs.files mapMcJarsToIntermediary.outputs.files.files
	outputs.file(processedMergedJar)
	outputs.upToDateWhen { false }

	doLast {
		def clientIn
		def serverIn
		def mergedIn
		def clientOut = calamusClientJar
		def serverOut = calamusServerJar
		def mergedOut = calamusMergedJar
		def dataFile

		if (nesting) {
			logger.lifecycle(":applying nests")

			clientIn = clientOut
			serverIn = serverOut
			mergedIn = mergedOut
			clientOut = nestedClientJar
			serverOut = nestedServerJar
			mergedOut = nestedMergedJar

			if (versionDetails.client && versionDetails.server) {
				dataFile = calamusMergedNestsFile
				Nester.nestJar(new Nester.Options().silent(true), mergedIn.toPath(), mergedOut.toPath(), dataFile.toPath())
			} else {
				if (versionDetails.client) {
					dataFile = versionDetails.sharedMappings ? calamusMergedNestsFile : calamusClientNestsFile
					Nester.nestJar(new Nester.Options().silent(true), clientIn.toPath(), clientOut.toPath(), dataFile.toPath())
				}
				if (versionDetails.server) {
					dataFile = versionDetails.sharedMappings ? calamusMergedNestsFile : calamusServerNestsFile
					Nester.nestJar(new Nester.Options().silent(true), serverIn.toPath(), clientOut.toPath(), dataFile.toPath())
				}
			}
		}
		if (signaturePatching) {
			logger.lifecycle(":patching signatures")

			clientIn = clientOut
			serverIn = serverOut
			mergedIn = mergedOut
			clientOut = signaturePatchedClientJar
			serverOut = signaturePatchedServerJar
			mergedOut = signaturePatchedMergedJar

			if (versionDetails.client && versionDetails.server) {
				dataFile = calamusMergedSparrowFile
				java.nio.file.Files.copy(mergedIn.toPath(), mergedOut.toPath(), StandardCopyOption.REPLACE_EXISTING)
				ApplyAction.run(dataFile.toPath(), List.of(mergedOut.toPath()))
			} else {
				if (versionDetails.client) {
					dataFile = versionDetails.sharedMappings ? calamusMergedSparrowFile : calamusClientSparrowFile
					java.nio.file.Files.copy(clientIn.toPath(), clientOut.toPath(), StandardCopyOption.REPLACE_EXISTING)
					ApplyAction.run(dataFile.toPath(), List.of(clientOut.toPath()))
				}
				if (versionDetails.server) {
					dataFile = versionDetails.sharedMappings ? calamusMergedSparrowFile : calamusServerSparrowFile
					java.nio.file.Files.copy(serverIn.toPath(), serverOut.toPath(), StandardCopyOption.REPLACE_EXISTING)
					ApplyAction.run(dataFile.toPath(), List.of(serverOut.toPath()))
				}
			}
		}

		java.nio.file.Files.copy(
			pickSide(versionDetails, mergedOut.toPath(), clientOut.toPath(), serverOut.toPath()),
			pickSide(versionDetails, processedMergedJar.toPath(), processedClientJar.toPath(), processedServerJar.toPath()),
			StandardCopyOption.REPLACE_EXISTING
		)
	}
}

task separateMappings(dependsOn: mapNestsToIntermediary) {
	group = enigmaGroup

	outputs.dirs(workingDir)
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":separating mappings for ${minecraft_version}")

		def nests = pickEnv(versionDetails, calamusMergedNestsFile, calamusClientNestsFile, calamusServerNestsFile)
		separateMappings(minecraft_version, mappingsGraphDir, workingDir, nests)
	}
}

task insertMappings(dependsOn: mapNestsToIntermediary) {
	group = enigmaGroup

	doLast {
		logger.lifecycle(":saving mappings for ${minecraft_version}")

		def nests = pickEnv(versionDetails, calamusMergedNestsFile, calamusClientNestsFile, calamusServerNestsFile)
		insertMappings(minecraft_version, mappingsGraphDir, workingDir, nests, PropagationDirection.NONE)
	}
}

task propagateMappingsDown(dependsOn: mapNestsToIntermediary) {
	group = enigmaGroup

	doLast {
		logger.lifecycle(":saving mappings for ${minecraft_version}")

		def nests = pickEnv(versionDetails, calamusMergedNestsFile, calamusClientNestsFile, calamusServerNestsFile)
		insertMappings(minecraft_version, mappingsGraphDir, workingDir, nests, PropagationDirection.DOWN)
	}
}

task propagateMappingsUp(dependsOn: mapNestsToIntermediary) {
	group = enigmaGroup

	doLast {
		logger.lifecycle(":saving mappings for ${minecraft_version}")

		def nests = pickEnv(versionDetails, calamusMergedNestsFile, calamusClientNestsFile, calamusServerNestsFile)
		insertMappings(minecraft_version, mappingsGraphDir, workingDir, nests, PropagationDirection.UP)
	}
}

task propagateMappings(dependsOn: mapNestsToIntermediary) {
	group = enigmaGroup

	doLast {
		logger.lifecycle(":saving mappings for ${minecraft_version}")

		def nests = pickEnv(versionDetails, calamusMergedNestsFile, calamusClientNestsFile, calamusServerNestsFile)
		insertMappings(minecraft_version, mappingsGraphDir, workingDir, nests, PropagationDirection.BOTH)
	}
}

void separateMappings(String minecraft_version, File mappingsGraphDir, File workingDir, File nestsFile) {
	VersionGraph graph = VersionGraph.of(Format.TINY_V2, mappingsGraphDir.toPath())
	Mappings mappings = MappingUtils.separateMappings(graph, minecraft_version)

	if (nestsFile.exists()) {
		Nests nests = Nests.empty()
		NesterIo.read(nests, nestsFile.toPath())

		mappings = MappingUtils.applyNests(mappings, nests)
	}

	mappings.setValidator(new MappingValidator() {

		@Override
		public boolean validate(ClassMapping c) {
			if (!MappingsDiff.safeIsDiff(ClassMapping.getSimplified(c.src()), c.get()) && (c.get().startsWith("C_") || c.get().startsWith("net/minecraft/unmapped/C_"))) {
				c.set("");
				return !c.getJavadoc().isEmpty() || c.hasChildren();
			}

			return true;
		}

		@Override
		public boolean validate(FieldMapping f) {
			if (!MappingsDiff.safeIsDiff(f.src(), f.get()) && f.get().startsWith("f_")) {
				f.set("");
				return !f.getJavadoc().isEmpty();
			}

			return true;
		}

		@Override
		public boolean validate(MethodMapping m) {
			if (!MappingsDiff.safeIsDiff(m.src(), m.get()) && (m.get().startsWith("m_") || m.get().equals("<init>") || m.get().equals("<clinit>"))) {
				m.set("");
				return !m.getJavadoc().isEmpty() || m.hasChildren();
			}

			return true;
		}

		@Override
		public boolean validate(ParameterMapping p) {
			if (p.get().startsWith("p_")) {
				p.set("");
				return !p.getJavadoc().isEmpty();
			}

			return true;
		}
	})

	Format.ENIGMA_DIR.writeMappings(workingDir.toPath(), mappings)
}

void insertMappings(String minecraft_version, File mappingsGraphDir, File workingDir, File nestsFile, PropagationDirection dir) {
	VersionGraph graph = VersionGraph.of(Format.TINY_V2, mappingsGraphDir.toPath());

	Mappings separatedMappings = MappingUtils.separateMappings(graph, minecraft_version);
	Mappings workingMappings = Format.ENIGMA_DIR.readMappings(workingDir.toPath());
	// enigma format does not have namespace info...
	workingMappings.setSrcNamespace(separatedMappings.getSrcNamespace())
	workingMappings.setDstNamespace(separatedMappings.getDstNamespace())

	if (nestsFile.exists()) {
		Nests nests = Nests.empty()
		NesterIo.read(nests, nestsFile.toPath())

		workingMappings = MappingUtils.undoNests(workingMappings, nests)
	}

	MappingsDiff changes = MappingUtils.diffMappings(separatedMappings, workingMappings);

	changes.setValidator(new MappingsDiffValidator() {

		@Override
		public boolean validate(ClassDiff c) {
			return check(c);
		}

		@Override
		public boolean validate(FieldDiff f) {
			return check(f);
		}

		@Override
		public boolean validate(MethodDiff m) {
			return check(m);
		}

		@Override
		public boolean validate(ParameterDiff p) {
			return check(p);
		}

		private boolean check(Diff d) {
			if (d.isDiff()) {
				if (d.get(DiffSide.A).isEmpty()) {
					// new mappings should be ignored, as any un-mapped members
					// should already be present as dummy mappings
					System.out.println("ignoring illegal change " + d);
					return false;
				}
				if (d.get(DiffSide.B).isEmpty()) {
					// removing a mapping is changed into a dummy mapping
					if (d.target() == MappingTarget.CLASS) {
						d.set(DiffSide.B, ClassMapping.getSimplified(d.src()));
					} else if (d.target() == MappingTarget.PARAMETER) {
						d.set(DiffSide.B, "p_" + ((ParameterDiff)d).getIndex());
					} else {
						d.set(DiffSide.B, d.src());
					}
				}
			}

			return true;
		}
	});

	PropagationOptions options = new PropagationOptions.Builder().setPropagationDirection(dir).lenient().build();
	MappingUtils.insertMappings(options, graph, changes, minecraft_version);

	delete(workingDir)
}

task enigma(dependsOn: [processMcJars, separateMappings]) {
	group = enigmaGroup

	doLast {
		def jar = pickSide(versionDetails, processedMergedJar, processedClientJar, processedServerJar)

		ant.setLifecycleLogLevel "WARN"
		ant.java(
			classname: 'cuchaz.enigma.gui.Main',
			classpath: configurations.enigmaRuntime.asPath,
			fork: true,
			spawn: true
		) {
			jvmarg(value: "-Xmx2048m")
			arg(value: '-jar')
			arg(value: jar.toPath())
			arg(value: '-mappings')
			arg(value: workingDir.toPath())
			arg(value: '-profile')
			arg(value: 'enigma_profile.json')
		}
	}
}

static void generateDummyMappings(File jar, File map) {
	MappingUtils.generateDummyMappings(Format.TINY_V2, MappingNamespace.INTERMEDIARY, MappingNamespace.NAMED, "^(net/minecraft/|com/mojang/).*\$", jar.toPath(), map.toPath())
}

static void diffDummyMappings(File a, File b, File d) {
	MappingUtils.diffMappings(Format.TINY_V2, a.toPath(), b.toPath(), d.toPath())
}

static void insertMappingChanges(VersionGraph graph, MappingsDiff changes, String version) {
	MappingUtils.insertMappings(new PropagationOptions.Builder().lenient().build(), graph, changes, version)
}

task resetGraph(dependsOn: mapMcJarsToIntermediary) {
	group = enigmaGroup

	outputs.dir(mappingsGraphDir)
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle("resetting mapping graph with ${minecraft_version} as the root")

		def jar = pickSide(versionDetails, calamusMergedJar, calamusClientJar, calamusServerJar)
		def map = new File(mappingsGraphDir, "${minecraft_version}.tiny")

		if (mappingsGraphDir.exists()) {
			delete(mappingsGraphDir)
		}
		mappingsGraphDir.mkdirs()

		generateDummyMappings(jar, map)
	}
}

task extendGraph(dependsOn: mapMcJarsToIntermediary) {
	group = enigmaGroup

	outputs.dir(mappingsGraphDir)
	outputs.upToDateWhen { false }

	doLast {
		VersionGraph graph = VersionGraph.of(Format.TINY_V2, mappingsGraphDir.toPath())

		if (!graph.hasVersion(from_minecraft_version)) {
			throw new RuntimeException("cannot extend graph from ${from_minecraft_version}: version does not exist in the graph!")
		}
		if (from_from_minecraft_version != null && !graph.hasVersion(from_from_minecraft_version)) {
			throw new RuntimeException("cannot extend graph from ${from_from_minecraft_version}: version does not exist in the graph!")
		}
		if (graph.hasVersion(minecraft_version)) {
			throw new RuntimeException("cannot extend graph to ${minecraft_version}: version already exists in graph!")
		}

		def jar = pickSide(versionDetails, calamusMergedJar, calamusClientJar, calamusServerJar)
		def fromJar = pickSide(fromVersionDetails, fromCalamusMergedJar, fromCalamusClientJar, fromCalamusServerJar)
		def fromFromJar = (from_from_minecraft_version == null)
			? null
			: pickSide(fromFromVersionDetails, fromFromCalamusMergedJar, fromFromCalamusClientJar, fromFromCalamusServerJar)

		if (!java.nio.file.Files.exists(fromJar.toPath())) {
			throw new RuntimeException("cannot extend graph from ${from_minecraft_version}: no calamus mapped jar found!")
		}
		if (from_from_minecraft_version != null && !java.nio.file.Files.exists(fromFromJar.toPath())) {
			throw new RuntimeException("cannot extend graph from ${from_from_minecraft_version}: no calamus mapped jar found!")
		}

		if (from_from_minecraft_version == null) {
			logger.lifecycle("extending mapping graph from ${from_minecraft_version} to ${minecraft_version}")
		} else {
			logger.lifecycle("extending mapping graph from ${from_from_minecraft_version}/${from_minecraft_version} to ${minecraft_version}")
		}

		File tmpGraphDir = file(".mappings")
		File fromFromDummy = new File(tmpGraphDir, "${from_from_minecraft_version ?: "kaput"}.tiny")
		File fromDummy = new File(tmpGraphDir, "${from_minecraft_version}.tiny")
		File dummy = new File(tmpGraphDir, "${minecraft_version}")
		File tmpDiff = new File(tmpGraphDir, "${from_from_minecraft_version ?: "kaput"}#${from_minecraft_version}.tinydiff")
		File tmpDiff1 = new File(tmpGraphDir, "${from_from_minecraft_version ?: "kaput"}#${minecraft_version}.tinydiff")
		File tmpDiff2 = new File(tmpGraphDir, "${from_minecraft_version}#${minecraft_version}.tinydiff")
		
		File diff1 = new File(mappingsGraphDir, "${from_from_minecraft_version ?: "kaput"}#${minecraft_version}.tinydiff")
		File diff2 = new File(mappingsGraphDir, "${from_minecraft_version}#${minecraft_version}.tinydiff")

		delete(tmpGraphDir)
		tmpGraphDir.mkdirs()

		if (from_from_minecraft_version != null) {
			generateDummyMappings(fromFromJar, fromFromDummy)
		}
		generateDummyMappings(fromJar, fromDummy)
		generateDummyMappings(jar, dummy)
		if (from_from_minecraft_version != null) {
			diffDummyMappings(fromFromDummy, fromDummy, tmpDiff)
			diffDummyMappings(fromFromDummy, dummy, tmpDiff1)
		}
		diffDummyMappings(fromDummy, dummy, tmpDiff2)

		delete(dummy)
		if (from_from_minecraft_version != null) {
			delete(fromDummy)
		}

		if (from_from_minecraft_version != null) {
			VersionGraph tmpGraph = VersionGraph.of(Format.TINY_V2, tmpGraphDir.toPath())
			
			Mappings mappings = MappingUtils.separateMappings(graph, from_from_minecraft_version)
			Mappings tmpMappings = MappingUtils.separateMappings(tmpGraph, from_from_minecraft_version)
			MappingsDiff changes = MappingUtils.diffMappings(tmpMappings, mappings)
			
			insertMappingChanges(tmpGraph, changes, from_from_minecraft_version)
		}

		VersionGraph tmpGraph = VersionGraph.of(Format.TINY_V2, tmpGraphDir.toPath())
		
		Mappings mappings = MappingUtils.separateMappings(graph, from_minecraft_version)
		Mappings tmpMappings = MappingUtils.separateMappings(tmpGraph, from_minecraft_version)
		MappingsDiff changes = MappingUtils.diffMappings(tmpMappings, mappings)

		insertMappingChanges(tmpGraph, changes, from_minecraft_version)

		if (from_from_minecraft_version != null) {
			java.nio.file.Files.copy(tmpDiff1.toPath(), diff1.toPath())
		}
		java.nio.file.Files.copy(tmpDiff2.toPath(), diff2.toPath())

		delete(tmpGraphDir)
	}
}
/*
 static List<String> getPublishedVersions(def artifact_id) {
 def xml = new URL("https://maven.ornithemc.net/releases/net/ornithemc/${artifact_id}/maven-metadata.xml").text
 def metadata = new XmlSlurper().parseText(xml)
 def versions = metadata.versioning.versions.version*.text()
 return versions
 }
 def publishedVersions
 try {
 publishedVersions = getPublishedVersions(artifact_id)
 } catch (ignored) {
 }
 def localMappingsPath = "$buildDir/v2Mappings"
 new File(localMappingsPath).mkdirs()
 file('mappings').eachFile {
 if (!it.name.endsWith(".tiny")) {
 return
 }
 def mcVer = it.name.replace(".tiny", "")
 if (publishedVersions != null && publishedVersions.contains(mcVer)) {
 return
 }
 File v1MappingFile = it
 File v2MappingFile = new File("$localMappingsPath/${it.name}")
 def conversionTask = "convert${it.name}ToV2"
 tasks.register(conversionTask) {
 group = "V2 Conversion"
 inputs.file(v1MappingFile)
 outputs.file(v2MappingFile)
 doLast {
 new ConvertMappingsCommand().run(
 "tiny",
 v1MappingFile.path,
 versionDetails.sharedMappings ? "tinyv2:${namespace}:clientOfficial:serverOfficial" : "tinyv2:official:${namespace}",
 v2MappingFile.path
 )
 }
 }
 Jar makeV1Jar = makeJar(mcVer, v1MappingFile, false)
 Jar makeV2Jar = makeJar(mcVer, v2MappingFile, true)
 build.dependsOn makeV1Jar
 build.dependsOn makeV2Jar
 makeV2Jar.dependsOn conversionTask
 publishing {
 publications {
 create("${mcVer.replace(" ", "")}_mavenJava", MavenPublication) {
 groupId 'net.ornithemc'
 artifactId artifact_id
 version mcVer
 artifact(makeV1Jar.archiveFile) {
 builtBy makeV1Jar
 }
 artifact(makeV2Jar.archiveFile) {
 builtBy makeV2Jar
 classifier = "v2"
 }
 }
 }
 }
 }
 def makeJar(String mcVersion, File mappings, boolean v2) {
 def jarFilename = "calamus-" + mcVersion + (v2 ? "-v2" : "")
 return task("${mcVersion}_makeJar" + (v2 ? "v2" : ""), type: Jar) {
 archiveBaseName.set(jarFilename)
 from(file(mappings)) {
 into "mappings"
 rename mappings.name, "mappings.tiny"
 }
 destinationDirectory = file("build/jars")
 }
 }
 publishing {
 repositories {
 if (ENV.MAVEN_URL) {
 maven {
 url ENV.MAVEN_URL
 credentials {
 username ENV.MAVEN_USERNAME
 password ENV.MAVEN_PASSWORD
 }
 authentication {
 basic(BasicAuthentication)
 }
 }
 }
 }
 }
 */